---
globs: **/test/**/*_test.rb
alwaysApply: false
---
# Minitest Best Practices

## Testing Framework Choice

**Default: Minitest (Class-Based Style)**
- Use Minitest's class-based testing style with standard Ruby method definitions
- Use `def test_does_a_thing` instead of Rails DSL `test "does a thing" do`
- Use standard Minitest assertions: `assert_equal`, `refute`, `assert` (not Rails additions like `assert_not`)
- Test classes should inherit from `ActiveSupport::TestCase` (Rails) or `Minitest::Test` (plain Ruby)

**RSpec Only When Necessary**
- Use RSpec for rswag specs to generate OpenAPI specifications
- RSpec guidance is preserved below for those specific cases
- For all other tests, use Minitest class-based style

### Minitest Test Class Structure

```ruby
require "test_helper"

class OrderProcessorTest < ActiveSupport::TestCase
  def test_processes_order_successfully
    # Arrange
    customer = customers(:john)
    order = Order.create!(customer: customer, status: "pending")

    # Act
    processor = OrderProcessor.new
    processed_order = processor.process(order)

    # Assert
    assert_equal("completed", processed_order.status)
  end

  def test_handles_invalid_order
    # Arrange
    order = Order.new  # Invalid order

    # Act
    processor = OrderProcessor.new
    result = processor.process(order)

    # Assert
    refute(result.success?)
  end
end
```

## ðŸ”´ Critical Rules - Apply First

### NEVER Do These
- âŒ NO `setup` or `teardown` methods - Creates hidden dependencies (equivalent to RSpec's `let`/`before`)
- âŒ NO instance variables (`@example`) - Use local variables, all setup in test method
- âŒ NO `let`, `let!`, `before`, `after`, `subject`, `described_class` (RSpec constructs)
- âŒ NO `shared_context`, `shared_examples` (RSpec constructs)
- âŒ NO Rails test DSL: `test "does a thing" do` - Use `def test_does_a_thing`
- âŒ NO Rails assertion aliases: `assert_not` - Use `refute`
- âŒ NO mocking internal services or business logic
- âŒ NO testing private methods or implementation details
- âŒ NO absolute count assertions: `assert_equal(5, Model.count)`
- âŒ NO factories (prefer fixtures or application code)
- âŒ NO random/Faker data for core test logic

### ALWAYS Do These
- âœ… Test observable behavior only (public interface)
- âœ… Arrange-Act-Assert structure in every test
- âœ… Explicit setup in test method body (all data visible, no `setup` method)
- âœ… Localize all test steps in test methods (no shared instance variables)
- âœ… Use fixtures for static data, application code for dynamic
- âœ… Mock external boundaries only (API calls, file system, time)
- âœ… One action per test, one clear assertion
- âœ… Explicit class names: `OrderProcessor.new` not `described_class.new`
- âœ… Document mocks with comment explaining external dependency
- âœ… Test specific values: `assert_equal("value", result)` not `assert_kind_of(String, result)`
- âœ… Existence checks: `assert(User.exists?(name: "value"))` not `assert_equal(5, User.count)`
- âœ… Standard Ruby method definitions: `def test_does_a_thing`
- âœ… Standard Minitest assertions: `assert_equal`, `refute`, `assert`

---

## Test Data Creation

### Preference Order (Highest to Lowest)

**1. Rails Fixtures** - Static, reusable data
```ruby
def test_finds_product_by_sku
  product = products(:basic_product)  # âœ… Fixture for static data
  assert_equal(product, Product.find_by_sku(product.sku))
end
```

**2. Application Code** - Dynamic, test-specific data
```ruby
def test_calculates_cart_total_price
  customer = Customer.create!(name: "John", email: "john@example.com")  # âœ… Explicit creation
  product = Product.create!(name: "Test", price: 1000)
  cart = Cart.create!(customer: customer)
  CartItem.create!(cart: cart, product: product, quantity: 2)

  assert_equal(2000, cart.total_price)  # âœ… Test specific value
end
```

**3. Factories** - Last resort only
```ruby
# Only when refactoring existing test files that already use factories
def test_associates_order_with_user
  user = FactoryBot.create(:user)      # âš ï¸ Factory as last resort
  order = FactoryBot.create(:order, user: user)

  assert_equal(user, order.user)
end
```

### Decision Tree
```
Is the data static and reusable across multiple tests?
â”œâ”€ YES â†’ Use fixtures: users(:john)
â””â”€ NO â†’ Use application code: User.create!(name: "Test")
```

---

## Mocking - External Boundaries Only

### External Boundaries (OK to Mock)

```ruby
# âœ… ImageKit uploads
mock_client = Minitest::Mock.new
mock_client.expect(:upload_file, response, [])
Dam::VariantBuilder.stub(:client, mock_client) do
  # test code
end

# âœ… HTTP requests
SsrfFilter.stub(:get, response) do
  # test code
end

# âœ… File system
File.stub(:read, content) do
  # test code
end

# âœ… Time (for time-sensitive logic)
Time.stub(:current, fixed_time) do
  # test code
end

# âœ… Background jobs
mock_job = Minitest::Mock.new
mock_job.expect(:perform_later, nil)
NotificationJob.stub(:new, mock_job) do
  # test code
end
```

### Internal Code (NEVER Mock)

```ruby
# âŒ NO mocking your services
Dam::VariantBuilder.stub(:build, result) do
  # ...
end

# âŒ NO mocking your models
User.stub(:create!, user) do
  # ...
end

# âŒ NO mocking your actions
Api::Orders::CreateAction.stub(:call, result) do
  # ...
end

# âŒ NO stubbing methods on class under test
order.stub(:calculate_total, 100) do
  # ...
end
```

### Boundary Method Pattern

DAM services use `.client` as external boundary:
```ruby
# âœ… Mock the external boundary
mock_client = Minitest::Mock.new
Dam::VariantBuilder.stub(:client, mock_client) do
  # test code
end

# âŒ Don't mock internal logic
Dam::VariantBuilder.stub(:build, result) do
  # ...
end
```

### Mocking Rules

- âœ… Only mock at external boundaries
- âœ… Use `Minitest::Mock` for interface compliance
- âœ… Document with comment: `# Mocking PaymentGateway (external API)`
- âŒ Never mock internal services or models

### Decision Tree
```
Is this an external service/API call?
â”œâ”€ YES â†’ Mock the boundary: Dam::VariantBuilder.client
â””â”€ NO â†’ Use real objects, let test fail if broken
```

---

## Arrange-Act-Assert Structure

Every test must follow AAA pattern:

```ruby
def test_calculates_shipping_cost_based_on_weight_and_distance
  # Arrange - Set up test data explicitly
  product = Product.create!(name: "Heavy Item", weight: 5.0)
  customer = Customer.create!(name: "John", zip_code: "90210")
  order = Order.create!(customer: customer, status: "pending")
  OrderItem.create!(order: order, product: product, quantity: 1)

  # Act - Perform single action
  calculator = ShippingCalculator.new
  cost = calculator.calculate_shipping(order)

  # Assert - One clear assertion
  assert_equal(15.50, cost)
end
```

**Rules:**
- âœ… Explicit setup visible in test method body (no `setup` method)
- âœ… All test steps localized in test method (no instance variables)
- âœ… One action under test
- âœ… One assertion (or multiple for same logical outcome)
- âŒ No asserting setup state: `assert(user.created_at.present?)`
- âŒ No mixing Arrange/Act phases

---

## Explicit Setup Only

### Avoid `setup` Methods - Localize All Test Steps

`setup` methods create hidden dependencies similar to RSpec's `let`/`before`. All test steps should be localized in the test method itself.

```ruby
# âœ… All setup explicit in test method
def test_processes_order_successfully
  customer = customers(:john)              # âœ… Explicit fixture
  product = products(:widget)              # âœ… Explicit fixture
  order = Order.create!(customer: customer, status: "pending")  # âœ… Explicit creation

  processor = OrderProcessor.new           # âœ… Explicit class name
  processed_order = processor.process(order)  # âœ… Descriptive variable

  assert_equal("completed", processed_order.status) # âœ… Specific value
end

# âŒ setup method creates hidden dependencies (equivalent to RSpec's let/before)
def setup
  @customer = customers(:john)            # âŒ Hidden dependency
  @order = Order.create!(customer: @customer)
end

def test_processes_order_successfully
  processor = OrderProcessor.new
  processed_order = processor.process(@order)  # âŒ Where did @order come from?
  assert_equal("completed", processed_order.status)
end
```

### Use Explicit Names

```ruby
# âœ… Explicit class names and variables
def test_processes_order_successfully
  customer = customers(:john)              # âœ… Explicit fixture
  product = products(:widget)              # âœ… Explicit fixture
  order = Order.create!(customer: customer, status: "pending")  # âœ… Explicit creation

  processor = OrderProcessor.new           # âœ… Explicit class name
  processed_order = processor.process(order)  # âœ… Descriptive variable

  assert_equal("completed", processed_order.status) # âœ… Specific value
end

# âŒ Implicit RSpec constructs (only for rswag specs)
let(:customer) { create(:customer) }
let(:order) { create(:order, customer: customer) }
subject { described_class.new }

it "processes order successfully" do
  processed_order = subject.process(order)
  expect(processed_order.status).to eq("completed")
end
```

### Service Test Pattern

```ruby
# âœ… Explicit service test
def test_synchronizes_rank_data
  rank = ranks(:gold)
  installation = installations(:active)

  synchronizer = Connect::Ranks::Synchronizer.new(  # âœ… Full class name
    rank_id: rank.id,
    installation: installation
  )
  sync_succeeded = synchronizer.sync                # âœ… Descriptive variable

  assert_equal(true, sync_succeeded)
end
```

---

## Assertions

### Test Specific Values

```ruby
# âœ… Test specific values
assert_equal("expected_value", result)
assert_equal("John Doe", user.name)
assert_equal(150.00, order.total)

# âŒ Don't test just types
assert_kind_of(String, result)
assert(user.name.present?)
```

### Use Existence Checks

```ruby
# âœ… Specific existence checks
assert(User.exists?(email: "test@example.com"))
assert(Order.exists?(order_number: "12345"))

# âŒ NO absolute counts (breaks when test data changes)
assert_equal(5, User.count)
assert_equal(10, Order.count)
```

### Test Relationships

```ruby
# âœ… Test relationships explicitly
assert_equal(users(:john), order.user)
assert_equal(products(:widget), cart_item.product)
```

### Multiple Assertions

```
Are assertions testing same logical outcome?
â”œâ”€ YES â†’ Multiple assertions acceptable
â””â”€ NO â†’ Split into separate tests
```

---

## RSpec Usage (rswag Specs Only)

RSpec is acceptable **only** when writing rswag specs to generate OpenAPI specifications. For rswag specs:

### When RSpec is Acceptable
- âœ… Writing OpenAPI specification tests with rswag
- âœ… Using rswag's DSL which requires RSpec syntax
- âœ… Generating API documentation from specs

### RSpec Guidance for rswag Specs

When writing rswag specs, follow these RSpec-specific patterns:

```ruby
# âœ… Acceptable RSpec syntax for rswag specs
RSpec.describe "Orders API", type: :request do
  path "/api/orders" do
    post "creates an order" do
      tags "Orders"
      consumes "application/json"
      produces "application/json"

      parameter name: :order, in: :body, schema: {
        type: :object,
        properties: {
          customer_id: { type: :integer },
          items: { type: :array }
        }
      }

      response "201", "order created" do
        let(:order) { { customer_id: 1, items: [] } }

        run_test! do |response|
          data = JSON.parse(response.body)
          expect(data["id"]).to be_present
        end
      end
    end
  end
end
```

**Note:** Even in rswag specs, prefer explicit setup over `let` when possible, but `let` is acceptable when required by rswag's DSL.

---

## Performance Targets

- **Unit tests:** <50ms per test
- **Integration tests:** <200ms per test
- **Feature/system tests:** <1000ms per test

Tests must be:
- âœ… Deterministic (same result every run)
- âœ… Isolated (run in any order, in parallel)
- âœ… Self-contained (no hidden dependencies)

---

## Complete Examples

### Good - Mixing Fixtures and Application Code

```ruby
def test_processes_order_and_updates_inventory
  # Fixtures for static data
  warehouse = warehouses(:main)
  product = products(:widget)

  # Application code for dynamic test data
  customer = Customer.create!(name: "Jane", email: "jane@example.com")
  order = Order.create!(customer: customer, warehouse: warehouse)
  OrderItem.create!(order: order, product: product, quantity: 3)

  # Act
  processor = OrderProcessor.new
  processed_order = processor.process(order)

  # Assert
  assert_equal("completed", processed_order.status)
end
```

### Good - Mocking External API

```ruby
def test_processes_payment_through_gateway
  # Mocking PaymentGateway (external API)  # âœ… Document external dependency
  mock_gateway = Minitest::Mock.new
  mock_gateway.expect(:charge, { success: true }, [100])

  processor = PaymentProcessor.new(mock_gateway)
  payment_result = processor.process(100)

  assert_equal(true, payment_result[:success])
  mock_gateway.verify  # Verify all expected calls were made
end
```

### Bad - Implicit Setup and Mocking

```ruby
# âŒ setup method creates hidden dependencies (equivalent to RSpec's let/before)
def setup
  @customer = customers(:john)            # âŒ Hidden dependency
  @order = Order.create!(customer: @customer, status: "pending")
end

def test_processes_order_successfully
  processor = OrderProcessor.new
  processed_order = processor.process(@order)  # âŒ Where did @order come from?
  assert_equal("completed", processed_order.status)
end

# âŒ Forbidden RSpec constructs (only acceptable in rswag specs)
let(:shop) { shops(:myshop) }
let(:product) { products(:myshop_beach_tshirt) }
before { sign_in user }
subject { described_class.new }

it "tests something" do
  # test code
end

# âŒ Mocking internal services
def test_processes_order
  inventory = Minitest::Mock.new
  InventoryService.stub(:update, inventory) do
    # ...
  end
end

# âŒ Testing implementation details
def test_calls_private_method
  order = Order.new
  order.stub(:calculate_tax, 10) do  # âŒ Testing private method
    order.process
  end
end
```

---

## Prohibited Patterns

### Forbidden Minitest Patterns
- âŒ `setup` and `teardown` methods - Creates hidden dependencies (equivalent to RSpec's `let`/`before`), all test steps must be localized in test methods
- âŒ Instance variables (`@example`) - Use local variables, all setup in test method
- âŒ Rails test DSL: `test "does a thing" do` - Use `def test_does_a_thing`
- âŒ Rails assertion aliases: `assert_not` - Use `refute`

### Forbidden RSpec Constructs (Only Acceptable in rswag Specs)
- âŒ `let`, `let!` - Creates hidden dependencies (except in rswag specs)
- âŒ `before`, `after` - Setup must be explicit in test body (except in rswag specs)
- âŒ `shared_context`, `shared_examples` - Tests must be self-contained (except in rswag specs)
- âŒ `subject`, `described_class` - Use explicit names (except in rswag specs)

### Forbidden Test Structure
- âŒ Hidden dependencies or implicit setup
- âŒ Shared state persisting across tests
- âŒ Multiple actions per test
- âŒ Testing private methods or internal state
- âŒ Complex factories with callbacks

### Forbidden Mocking
- âŒ Mocking internal services or domain models
- âŒ Stubbing methods on class under test
- âŒ Mocking without documenting external dependency

### Forbidden Assertions
- âŒ Multiple unrelated assertions
- âŒ Asserting setup state
- âŒ Absolute count assertions: `assert_equal(5, Model.count)`

---

## AI Guidelines

### Test Readability
- âœ… Descriptive test method names: `def test_processes_order_successfully`
- âœ… Comments for complex business logic
- âœ… Explicit, visible test data creation
- âœ… Clear variable names (no abbreviations)

### Pattern Recognition
- âœ… Descriptive variable names: `processed_order`, `payment_result`, `sync_succeeded`
- âœ… Predictable structure: setup â†’ action â†’ assertion
- âœ… Explicit class instantiation: `ServiceClass.new`
- âœ… Document external dependencies with comments
- âœ… Standard Minitest assertions: `assert_equal(expected, actual)`
- âœ… Standard Ruby method definitions: `def test_does_a_thing`

---

## Quick Reference Checklist

### Test Structure
- [ ] Arrange-Act-Assert pattern
- [ ] All setup explicit in test method body (no `setup` method)
- [ ] All test steps localized in test method (no instance variables)
- [ ] One action under test
- [ ] One clear assertion
- [ ] Using `def test_does_a_thing` (not Rails DSL `test "does a thing" do`)
- [ ] No forbidden Minitest patterns

### Test Data
- [ ] Fixtures for static data
- [ ] Application code for dynamic data
- [ ] No factories (unless refactoring existing)
- [ ] All data visible in test

### Mocking
- [ ] Only mock external boundaries
- [ ] Document external dependency
- [ ] Use `Minitest::Mock` for mocks
- [ ] No mocking internal code

### Assertions
- [ ] Test specific values with `assert_equal(expected, actual)`
- [ ] Use standard Minitest assertions: `assert`, `refute`, `assert_equal`
- [ ] Use existence checks, not counts
- [ ] Test relationships explicitly
- [ ] No asserting setup state

### Code Quality
- [ ] Explicit class names
- [ ] Descriptive variable names
- [ ] Self-contained test
- [ ] Deterministic and fast

---

## Summary

**Testing Framework:**
- **Default:** Minitest class-based style with `def test_does_a_thing`
- **RSpec:** Only for rswag specs to generate OpenAPI specifications
- **Assertions:** Standard Minitest (`assert_equal`, `refute`, `assert`) not Rails aliases (`assert_not`)

**Core Principles:**
1. Test observable behavior only
2. Explicit setup in test method body (no `setup` method - equivalent to RSpec's `let`/`before`)
3. Localize all test steps in test methods (no shared instance variables)
4. Fixtures > Application code > Factories
5. Mock external boundaries only
6. One action, one assertion per test

**Enforcement:**
- Any violation of prohibited patterns = test failure
- All test data visible in test method body
- No `setup` or `teardown` methods - all steps localized in test methods
- Tests must be: self-contained, readable top-to-bottom, deterministic, focused on one behavior
- Use Minitest class-based style unless writing rswag specs
